<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>DrawHelloKitty</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    body {
      font-family: 'Comic Sans MS', cursive, sans-serif;
      background: linear-gradient(to bottom right, #ffccff, #ff99cc);
      text-align: center;
      padding: 30px;
      color: #d63384;
      margin: 0;
      min-height: 100vh;
    }

    h1 {
      font-size: 48px;
      color: #ff3399;
      text-shadow: 2px 2px 0px rgba(255, 255, 255, 0.8);
      margin-top: 0;
    }

    .toolbox {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }

    .section {
      background: rgba(255, 230, 240, 0.9);
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 4px 6px rgba(255, 138, 198, 0.5);
      min-width: 220px;
    }

    .section h3 {
      margin-bottom: 10px;
      margin-top: 0;
      color: #ff3399;
      font-size: 24px;
    }

    button, select, input[type="text"], input[type="color"] {
      font-family: inherit;
      background: #ff99cc;
      border: none;
      padding: 12px 16px;
      margin: 5px;
      border-radius: 10px;
      box-shadow: 2px 2px 0 #ff5caa;
      cursor: pointer;
      font-size: 18px;
      transition: all 0.2s;
    }

    button:hover, select:hover {
      background: #ff66b2;
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

    #canvas {
      border: 4px dotted #fff;
      background: white;
      margin-top: 20px;
      border-radius: 12px;
      cursor: crosshair;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
    }

    footer {
      margin-top: 30px;
      font-size: 18px;
      color: #aa1166;
    }

    .game-container {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 100;
      justify-content: center;
      align-items: center;
    }

    .game-window {
      background: #ffe6f0;
      padding: 20px;
      border-radius: 20px;
      width: 80%;
      max-width: 500px;
      box-shadow: 0 0 20px rgba(255, 140, 180, 0.8);
    }

    .game-canvas {
      background: white;
      border: 3px dashed #ff99cc;
      border-radius: 10px;
      margin: 10px auto;
      display: block;
    }

    .close-game {
      background: #ff5caa;
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 10px;
      margin-top: 10px;
      font-size: 18px;
    }

    .sticker-palette {
      display: none;
      position: absolute;
      background: #ffe6f0;
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      z-index: 10;
    }

    .sticker {
      font-size: 40px;
      cursor: pointer;
      margin: 5px;
      display: inline-block;
    }

    .sticker:hover {
      transform: scale(1.2);
    }

    .tab-container {
      display: flex;
      justify-content: center;
      margin-bottom: 15px;
    }

    .tab {
      padding: 12px 20px;
      background: #ff99cc;
      border-radius: 10px 10px 0 0;
      margin: 0 5px;
      cursor: pointer;
      font-size: 20px;
    }

    .tab.active {
      background: #ff66b2;
      color: white;
    }

    .content-area {
      display: none;
    }

    .content-area.active {
      display: block;
    }

    .undo-redo {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 10px;
    }

    .prompt-container {
      margin: 10px auto;
      font-size: 20px;
      color: #ff3399;
    }

    @media (max-width: 768px) {
      .toolbox {
        flex-direction: column;
        align-items: center;
      }
      #canvas {
        width: 95%;
        height: auto;
      }
      h1 {
        font-size: 36px;
      }
      button, select, input {
        font-size: 16px;
        padding: 10px 14px;
      }
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-20px); }
    }

    .reward-animation {
      font-size: 60px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      animation: bounce 0.5s 3;
    }
  </style>
</head>
<body>
  <h1>Welcome to DrawHelloKitty! ‚úèÔ∏èüé®</h1>

  <div class="tab-container">
    <div class="tab active" onclick="switchTab('drawing')">Drawing</div>
    <div class="tab" onclick="switchTab('games')">Games</div>
    <div class="tab" onclick="switchTab('learn')">Learn to Draw</div>
  </div>

  <div id="drawing-tab" class="content-area active">
    <div class="prompt-container" id="drawingPrompt">Click "New Prompt" for a fun drawing idea!</div>
    <div class="toolbox">
      <div class="section">
        <h3>Brush Tools:</h3>
        <select id="brushType" title="Choose your drawing tool">
          <option value="crayon">Crayon</option>
          <option value="marker">Marker</option>
          <option value="pencil">Pencil</option>
          <option value="spray">Spray</option>
        </select>
        <h3>Color:</h3>
        <input type="color" id="colorPicker" value="#ff1493" title="Pick a color"/>
        <h3>Size: <span id="sizeValue">5</span></h3>
        <input type="range" id="sizeSlider" min="1" max="30" value="5" title="Adjust brush size"/>
      </div>

      <div class="section">
        <h3>Shapes:</h3>
        <button onclick="drawShape('circle')" title="Draw a circle">‚≠ï Circle</button>
        <button onclick="drawShape('square')" title="Draw a square">‚¨õ Square</button>
        <button onclick="drawShape('triangle')" title="Draw a triangle">üî∫ Triangle</button>
        <button onclick="drawShape('star')" title="Draw a star">‚≠ê Star</button>
      </div>

      <div class="section">
        <h3>Stickers & Text:</h3>
        <button onclick="showStickers()" title="Choose a sticker">üéÄ Stickers</button>
        <button onclick="stampEmoji('üò∫')" title="Add a kitty sticker">üò∫ Kitty</button>
        <button onclick="stampEmoji('üå∏')" title="Add a flower sticker">üå∏ Flower</button>
        <h3>Your Name:</h3>
        <input type="text" id="nameInput" placeholder="Enter your name" title="Type your name"/>
        <button onclick="addName()" title="Add your name to the canvas">Add Name</button>
      </div>

      <div class="section">
        <h3>Canvas Tools:</h3>
        <button onclick="toggleEraser()" title="Switch to eraser">üßΩ Eraser</button>
        <button onclick="clearCanvas()" title="Clear the canvas">üóëÔ∏è Clear</button>
        <button onclick="fillCanvas()" title="Fill with color">üé® Fill</button>
        <div class="undo-redo">
          <button onclick="undo()" title="Undo last action">‚Ü©Ô∏è Undo</button>
          <button onclick="redo()" title="Redo last action">‚Ü™Ô∏è Redo</button>
        </div>
      </div>

      <div class="section">
        <h3>Save & Share:</h3>
        <button onclick="saveImage('png')" title="Save as PNG">üíæ Save PNG</button>
        <button onclick="saveImage('jpeg')" title="Save as JPEG">üì∑ Save JPEG</button>
        <button onclick="saveImage('pdf')" title="Save as PDF">üìÑ Save PDF</button>
        <button onclick="printCanvas()" title="Print your drawing">üñ®Ô∏è Print</button>
        <h3>Background:</h3>
        <select onchange="changeTheme(this.value)" title="Change canvas background">
          <option value="white">White</option>
          <option value="pink">Pink</option>
          <option value="sky">Sky Blue</option>
          <option value="mint">Mint Green</option>
        </select>
      </div>

      <div class="section">
        <h3>Fun Activities:</h3>
        <button onclick="generateDrawingPrompt()" title="Get a new drawing idea">‚ú® New Prompt</button>
        <button onclick="startColoringBook()" title="Color a picture">üñçÔ∏è Coloring Book</button>
        <button onclick="startConnectDots()" title="Connect the dots">üî¢ Connect Dots</button>
      </div>
    </div>

    <canvas id="canvas" width="700" height="500"></canvas>
  </div>

  <div id="games-tab" class="content-area">
    <div class="section" style="max-width: 600px; margin: 0 auto;">
      <h2>üéÆ Fun Games üéÆ</h2>
      <button onclick="startMemoryGame()" title="Match the cards">üß† Memory Match</button>
      <button onclick="startGuessingGame()" title="Guess the color">üé® Color Guess</button>
      <button onclick="startDrawingGame()" title="Draw a challenge">‚úèÔ∏è Draw Challenge</button>
      <button onclick="startScienceQuiz()" title="Answer science questions">üî¨ Science Quiz</button>
      <button onclick="startBarbieDressUp()" title="Design Barbie's outfit">üëó Barbie Dress-Up</button>
      <button onclick="startScienceExperiment()" title="Mix chemicals">üß™ Science Experiment</button>
    </div>
  </div>

  <div id="learn-tab" class="content-area">
    <div class="section" style="max-width: 600px; margin: 0 auto;">
      <h2>‚úèÔ∏è Learn to Draw ‚úèÔ∏è</h2>
      <div id="tutorial-steps">
        <h3>Let's draw a cute cat!</h3>
        <ol style="text-align: left; font-size: 18px;">
          <li>Draw a circle for the head</li>
          <li>Add two triangle ears on top</li>
          <li>Draw two dots for eyes</li>
        </ol>
        <button onclick="showStepByStep('cat')" title="See how to draw a cat">Show Me How</button>
        
        <h3 style="margin-top: 20px;">Let's draw a flower!</h3>
        <ol style="text-align: left; font-size: 18px;">
          <li>Draw a small circle in the center</li>
          <li>Add petals around it</li>
          <li>Draw a stem</li>
        </ol>
        <button onclick="showStepByStep('flower')" title="See how to draw a flower">Show Me How</button>
      </div>
    </div>
  </div>

  <div class="sticker-palette" id="stickerPalette">
    <div class="sticker" onclick="stampEmoji('üò∫')" title="Kitty sticker">üò∫</div>
    <div class="sticker" onclick="stampEmoji('üê∂')" title="Puppy sticker">üê∂</div>
    <div class="sticker" onclick="stampEmoji('üå∏')" title="Flower sticker">üå∏</div>
    <div class="sticker" onclick="stampEmoji('‚≠ê')" title="Star sticker">‚≠ê</div>
    <div class="sticker" onclick="stampEmoji('üéÄ')" title="Bow sticker">üéÄ</div>
  </div>

  <div class="game-container" id="gameContainer">
    <div class="game-window">
      <h2 id="gameTitle">Game</h2>
      <canvas class="game-canvas" id="gameCanvas" width="400" height="400"></canvas>
      <div id="gameInstructions" style="margin: 10px 0; font-size: 18px;"></div>
      <div id="gameScore" style="font-weight: bold; margin: 10px 0; font-size: 18px;"></div>
      <button class="close-game" onclick="closeGame()" title="Close the game">Close Game</button>
    </div>
  </div>

  <footer>Made with ‚ù§Ô∏è by Nakshu | ¬© 2023 DrawHelloKitty</footer>

  <script>
    // Canvas setup
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const gameCanvas = document.getElementById("gameCanvas");
    const gameCtx = gameCanvas.getContext("2d");

    // Drawing state
    let drawing = false;
    let brushColor = "#ff1493";
    let brushSize = 5;
    let isEraser = false;
    let currentBrush = "crayon";
    let drawingHistory = [];
    let historyIndex = -1;
    let connectDotsMode = false;
    let dotPoints = [];
    let coloringBookMode = false;
    let coloringBookImage = null;
    let lastPoint = null;

    // Game state
    let currentGame = null;
    let gameScore = 0;
    let memoryCards = [];
    let flippedCards = [];
    let matchedCards = [];
    let colorOptions = [];
    let targetColor = "";
    let drawingChallengeWord = "";
    let drawingChallengeTimer = null;
    let timeLeft = 30;
    let currentQuestion = 0;
    let questions = [];
    let barbieOutfit = { dressColor: "#ff66b2", pattern: "none" };
    let experimentChemicals = [];

    // Initialize
    document.getElementById("colorPicker").value = brushColor;
    document.getElementById("sizeSlider").oninput = function(e) {
      brushSize = e.target.value;
      document.getElementById("sizeValue").textContent = brushSize;
    };

    // Event listeners
    canvas.onmousedown = startDrawing;
    canvas.onmouseup = stopDrawing;
    canvas.onmouseleave = stopDrawing;
    canvas.onmousemove = draw;
    canvas.ontouchstart = handleTouchStart;
    canvas.ontouchmove = handleTouchMove;
    canvas.ontouchend = stopDrawing;

    document.getElementById("brushType").onchange = function(e) {
      currentBrush = e.target.value;
      isEraser = false;
    };

    document.getElementById("colorPicker").oninput = function(e) {
      brushColor = e.target.value;
      isEraser = false;
    };

    // Tab switching
    function switchTab(tab) {
      console.log(`Switching to tab: ${tab}`);
      const tabs = document.querySelectorAll(".tab");
      const contents = document.querySelectorAll(".content-area");
      tabs.forEach(t => t.classList.remove("active"));
      contents.forEach(c => c.classList.remove("active"));
      document.querySelector(`.tab[onclick="switchTab('${tab}')"]`).classList.add("active");
      document.getElementById(`${tab}-tab`).classList.add("active");
      if (tab !== "drawing") {
        coloringBookMode = false;
        connectDotsMode = false;
      }
    }

    // Drawing functions
    function startDrawing(e) {
      console.log("Starting to draw");
      if (coloringBookMode || connectDotsMode) {
        handleSpecialMode(e);
        return;
      }
      drawing = true;
      saveDrawingState();
      draw(e);
    }

    function stopDrawing() {
      console.log("Stopping drawing");
      drawing = false;
      ctx.beginPath();
      lastPoint = null;
    }

    function draw(e) {
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX || e.touches[0].clientX) - rect.left;
      const y = (e.clientY || e.touches[0].clientY) - rect.top;
      ctx.lineJoin = "round";
      ctx.lineCap = "round";
      if (isEraser) {
        ctx.globalCompositeOperation = "destination-out";
        ctx.strokeStyle = "rgba(0,0,0,1)";
      } else {
        ctx.globalCompositeOperation = "source-over";
        ctx.strokeStyle = brushColor;
        ctx.fillStyle = brushColor;
      }
      ctx.lineWidth = brushSize;
      switch(currentBrush) {
        case "crayon":
          drawCrayon(x, y);
          break;
        case "marker":
          drawMarker(x, y);
          break;
        case "pencil":
          drawPencil(x, y);
          break;
        case "spray":
          drawSpray(x, y);
          break;
        default:
          drawCrayon(x, y);
      }
    }

    function drawCrayon(x, y) {
      if (lastPoint) {
        ctx.beginPath();
        ctx.moveTo(lastPoint.x, lastPoint.y);
        ctx.lineTo(x, y);
        ctx.stroke();
      }
      ctx.beginPath();
      ctx.arc(x, y, brushSize/2, 0, Math.PI*2);
      ctx.fill();
      lastPoint = { x, y };
    }

    function drawMarker(x, y) {
      if (lastPoint) {
        ctx.beginPath();
        ctx.moveTo(lastPoint.x, lastPoint.y);
        ctx.lineTo(x, y);
        ctx.stroke();
      }
      lastPoint = { x, y };
    }

    function drawPencil(x, y) {
      ctx.globalAlpha = 0.7;
      if (lastPoint) {
        ctx.beginPath();
        ctx.moveTo(lastPoint.x, lastPoint.y);
        ctx.lineTo(x, y);
        ctx.stroke();
      }
      lastPoint = { x, y };
      ctx.globalAlpha = 1;
    }

    function drawSpray(x, y) {
      const density = brushSize * 2;
      for (let i = 0; i < density; i++) {
        const radius = Math.random() * brushSize;
        const angle = Math.random() * Math.PI * 2;
        const sprayX = x + Math.cos(angle) * radius;
        const sprayY = y + Math.sin(angle) * radius;
        ctx.beginPath();
        ctx.arc(sprayX, sprayY, 1, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function handleTouchStart(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent("mousedown", {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      canvas.dispatchEvent(mouseEvent);
    }

    function handleTouchMove(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent("mousemove", {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      canvas.dispatchEvent(mouseEvent);
    }

    // Shape drawing functions
    function drawShape(shape) {
      console.log(`Drawing shape: ${shape}`);
      saveDrawingState();
      ctx.fillStyle = brushColor;
      ctx.strokeStyle = brushColor;
      ctx.lineWidth = brushSize;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const size = Math.min(canvas.width, canvas.height) * 0.3;
      ctx.beginPath();
      switch(shape) {
        case "circle":
          ctx.arc(centerX, centerY, size/2, 0, Math.PI * 2);
          ctx.fill();
          break;
        case "square":
          ctx.rect(centerX - size/2, centerY - size/2, size, size);
          ctx.fill();
          break;
        case "triangle":
          ctx.moveTo(centerX, centerY - size/2);
          ctx.lineTo(centerX + size/2, centerY + size/2);
          ctx.lineTo(centerX - size/2, centerY + size/2);
          ctx.closePath();
          ctx.fill();
          break;
        case "star":
          drawStar(centerX, centerY, 5, size/2, size/4);
          ctx.fill();
          break;
      }
    }

    function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
      let rot = Math.PI/2 * 3;
      let x = cx;
      let y = cy;
      let step = Math.PI / spikes;
      ctx.beginPath();
      ctx.moveTo(cx, cy - outerRadius);
      for(let i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerRadius;
        y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y);
        rot += step;
        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y);
        rot += step;
      }
      ctx.lineTo(cx, cy - outerRadius);
      ctx.closePath();
    }

    // Tool functions
    function toggleEraser() {
      console.log(`Toggling eraser: ${!isEraser}`);
      isEraser = !isEraser;
      document.getElementById("brushType").value = isEraser ? "crayon" : currentBrush;
    }

    function clearCanvas() {
      console.log("Clearing canvas");
      saveDrawingState();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (coloringBookMode && coloringBookImage) {
        ctx.drawImage(coloringBookImage, 0, 0, canvas.width, canvas.height);
      }
      if (connectDotsMode) {
        renderDots();
      }
    }

    function fillCanvas() {
      console.log("Filling canvas");
      saveDrawingState();
      ctx.fillStyle = brushColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      if (coloringBookMode && coloringBookImage) {
        ctx.drawImage(coloringBookImage, 0, 0, canvas.width, canvas.height);
      }
      if (connectDotsMode) {
        renderDots();
      }
    }

    function addName() {
      console.log("Adding name");
      saveDrawingState();
      const name = document.getElementById("nameInput").value;
      if (!name) return;
      ctx.fillStyle = brushColor;
      ctx.font = "24px Comic Sans MS";
      ctx.fillText(name, 20, 40);
    }

    function stampEmoji(emoji) {
      console.log(`Stamping emoji: ${emoji}`);
      saveDrawingState();
      ctx.font = `40px serif`;
      ctx.fillStyle = brushColor;
      const x = Math.random() * (canvas.width - 50) + 25;
      const y = Math.random() * (canvas.height - 50) + 25;
      ctx.fillText(emoji, x, y);
    }

    function showStickers() {
      console.log("Showing stickers");
      const palette = document.getElementById("stickerPalette");
      palette.style.display = "block";
      palette.style.left = "50px";
      palette.style.top = "50px";
      setTimeout(() => {
        document.addEventListener("click", closeStickers);
      }, 10);
    }

    function closeStickers(e) {
      if (!document.getElementById("stickerPalette").contains(e.target)) {
        console.log("Closing stickers");
        document.getElementById("stickerPalette").style.display = "none";
        document.removeEventListener("click", closeStickers);
      }
    }

    // History functions
    function saveDrawingState() {
      if (historyIndex < drawingHistory.length - 1) {
        drawingHistory = drawingHistory.slice(0, historyIndex + 1);
      }
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      drawingHistory.push(imageData);
      historyIndex = drawingHistory.length - 1;
      if (drawingHistory.length > 20) {
        drawingHistory.shift();
        historyIndex--;
      }
    }

    function undo() {
      console.log("Undoing");
      if (historyIndex <= 0) return;
      historyIndex--;
      ctx.putImageData(drawingHistory[historyIndex], 0, 0);
      if (coloringBookMode && coloringBookImage) {
        ctx.drawImage(coloringBookImage, 0, 0, canvas.width, canvas.height);
      }
      if (connectDotsMode) {
        renderDots();
      }
    }

    function redo() {
      console.log("Redoing");
      if (historyIndex >= drawingHistory.length - 1) return;
      historyIndex++;
      ctx.putImageData(drawingHistory[historyIndex], 0, 0);
      if (coloringBookMode && coloringBookImage) {
        ctx.drawImage(coloringBookImage, 0, 0, canvas.width, canvas.height);
      }
      if (connectDotsMode) {
        renderDots();
      }
    }

    // Drawing Prompt Generator
    function generateDrawingPrompt() {
      console.log("Generating drawing prompt");
      const prompts = [
        "Draw a rocket in space üöÄ",
        "Draw a rainbow with clouds üåà",
        "Draw a scientist in a lab üß™",
        "Draw a dinosaur in a forest ü¶ñ",
        "Draw the solar system ‚òÄÔ∏è"
      ];
      const prompt = prompts[Math.floor(Math.random() * prompts.length)];
      document.getElementById("drawingPrompt").textContent = prompt;
    }

    // Coloring book mode
    function startColoringBook() {
      console.log("Starting coloring book");
      saveDrawingState();
      coloringBookMode = true;
      connectDotsMode = false;
      clearCanvas();
      coloringBookImage = new Image();
      coloringBookImage.src = createColoringBookImage();
      coloringBookImage.onload = () => {
        ctx.drawImage(coloringBookImage, 0, 0, canvas.width, canvas.height);
      };
    }

    function createColoringBookImage() {
      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      const tempCtx = tempCanvas.getContext("2d");
      tempCtx.strokeStyle = "black";
      tempCtx.lineWidth = 2;
      tempCtx.beginPath();
      tempCtx.arc(canvas.width/2, canvas.height/2, 100, 0, Math.PI * 2);
      tempCtx.stroke();
      return tempCanvas.toDataURL();
    }

    // Connect-the-dots mode
    function startConnectDots() {
      console.log("Starting connect-the-dots");
      saveDrawingState();
      connectDotsMode = true;
      coloringBookMode = false;
      clearCanvas();
      dotPoints = generateDots();
      renderDots();
    }

    function generateDots() {
      const points = [];
      const numDots = 5;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = 100;
      for (let i = 0; i < numDots; i++) {
        const angle = (i / numDots) * Math.PI * 2;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;
        points.push({ x, y, number: i + 1 });
      }
      return points;
    }

    function renderDots() {
      ctx.fillStyle = "black";
      ctx.font = "20px Comic Sans MS";
      dotPoints.forEach(point => {
        ctx.beginPath();
        ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillText(point.number, point.x + 10, point.y + 10);
      });
    }

    function handleSpecialMode(e) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX || e.touches[0].clientX) - rect.left;
      const y = (e.clientY || e.touches[0].clientY) - rect.top;
      if (connectDotsMode) {
        const clickedDot = dotPoints.find(dot => 
          Math.sqrt((dot.x - x) ** 2 + (dot.y - y) ** 2) < 10
        );
        if (clickedDot && clickedDot.number === dotPoints[0].number) {
          saveDrawingState();
          ctx.beginPath();
          ctx.moveTo(clickedDot.x, clickedDot.y);
          dotPoints.push(dotPoints.shift());
          renderDots();
        } else if (clickedDot && clickedDot.number === dotPoints[0].number + 1) {
          saveDrawingState();
          ctx.strokeStyle = brushColor;
          ctx.lineWidth = brushSize;
          ctx.lineTo(clickedDot.x, clickedDot.y);
          ctx.stroke();
          dotPoints.push(dotPoints.shift());
          renderDots();
        }
      }
    }

    // Save/export functions
    function saveImage(type) {
      console.log(`Saving image as: ${type}`);
      let link = document.createElement("a");
      const fileName = `DrawHelloKitty_${new Date().toISOString().slice(0,10)}.${type}`;
      link.download = fileName;
      if (type === "pdf") {
        try {
          const { jsPDF } = window.jspdf;
          const pdf = new jsPDF();
          const imgData = canvas.toDataURL("image/png");
          pdf.addImage(imgData, "PNG", 10, 10, canvas.width / 4, canvas.height / 4);
          pdf.save(fileName);
        } catch (e) {
          console.error("PDF save error:", e);
          alert("PDF export failed. Try PNG or JPEG.");
        }
        return;
      }
      link.href = canvas.toDataURL(`image/${type}`);
      link.click();
    }

    function printCanvas() {
      console.log("Printing canvas");
      const dataUrl = canvas.toDataURL("image/png");
      const windowContent = '<!DOCTYPE html><html><head><title>Print Canvas</title></head><body><img src="' + dataUrl + '"></body></html>';
      const printWin = window.open('', '', 'width=800,height=600');
      printWin.document.write(windowContent);
      printWin.document.close();
      printWin.focus();
      printWin.print();
      printWin.close();
    }

    // Game functions
    function closeGame() {
      console.log("Closing game");
      document.getElementById("gameContainer").style.display = "none";
      gameCanvas.onclick = null;
      if (drawingChallengeTimer) {
        clearInterval(drawingChallengeTimer);
        drawingChallengeTimer = null;
      }
      currentGame = null;
      gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
      document.querySelectorAll(".reward-animation").forEach(el => el.remove());
    }

    function showRewardAnimation() {
      const reward = document.createElement("div");
      reward.className = "reward-animation";
      reward.textContent = "üò∫";
      document.getElementById("gameContainer").appendChild(reward);
      setTimeout(() => reward.remove(), 1500);
    }

    function startMemoryGame() {
      console.log("Starting Memory Game");
      currentGame = "memory";
      document.getElementById("gameContainer").style.display = "flex";
      document.getElementById("gameTitle").textContent = "Memory Match Game";
      document.getElementById("gameInstructions").textContent = "Click cards to find matching pairs!";
      gameScore = 0;
      document.getElementById("gameScore").textContent = `Score: ${gameScore}`;
      memoryCards = ["üò∫", "üò∫", "üå∏", "üå∏"].sort(() => Math.random() - 0.5);
      matchedCards = [];
      flippedCards = [];
      renderMemoryGame();
      gameCanvas.onclick = handleMemoryCardClick;
    }

    function renderMemoryGame() {
      gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
      const cardWidth = 80;
      const cardHeight = 80;
      const gap = 20;
      for (let i = 0; i < 4; i++) {
        const x = (i % 2) * (cardWidth + gap) + gap;
        const y = Math.floor(i / 2) * (cardHeight + gap) + gap;
        gameCtx.fillStyle = matchedCards.includes(i) || flippedCards.includes(i) ? "#fff" : "#ff66b2";
        gameCtx.fillRect(x, y, cardWidth, cardHeight);
        if (matchedCards.includes(i) || flippedCards.includes(i)) {
          gameCtx.font = "40px serif";
          gameCtx.fillStyle = "black";
          gameCtx.fillText(memoryCards[i], x + 20, y + 60);
        }
      }
    }

    function handleMemoryCardClick(e) {
      console.log("Memory card clicked");
      const rect = gameCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const cardWidth = 80;
      const cardHeight = 80;
      const gap = 20;
      const col = Math.floor((x - gap) / (cardWidth + gap));
      const row = Math.floor((y - gap) / (cardHeight + gap));
      const index = row * 2 + col;
      if (col >= 0 && col < 2 && row >= 0 && row < 2 && !matchedCards.includes(index) && !flippedCards.includes(index)) {
        flippedCards.push(index);
        renderMemoryGame();
        if (flippedCards.length === 2) {
          const [first, second] = flippedCards;
          if (memoryCards[first] === memoryCards[second]) {
            matchedCards.push(first, second);
            gameScore += 10;
            showRewardAnimation();
            document.getElementById("gameScore").textContent = `Score: ${gameScore}`;
            flippedCards = [];
            if (matchedCards.length === memoryCards.length) {
              setTimeout(() => alert("You won!"), 500);
            }
          } else {
            setTimeout(() => {
              flippedCards = [];
              renderMemoryGame();
            }, 1000);
          }
        }
      }
    }

    function startGuessingGame() {
      console.log("Starting Color Guessing Game");
      currentGame = "colorGuessing";
      document.getElementById("gameContainer").style.display = "flex";
      document.getElementById("gameTitle").textContent = "Color Guessing Game";
      document.getElementById("gameInstructions").textContent = "Click the matching color!";
      gameScore = 0;
      document.getElementById("gameScore").textContent = `Score: ${gameScore}`;
      generateColorRound();
      gameCanvas.onclick = handleColorGuess;
    }

    function generateColorRound() {
      colorOptions = [
        `#${Math.floor(Math.random()*16777215).toString(16)}`,
        `#${Math.floor(Math.random()*16777215).toString(16)}`,
        `#${Math.floor(Math.random()*16777215).toString(16)}`
      ];
      targetColor = colorOptions[Math.floor(Math.random() * 3)];
      renderColorGuessingGame();
    }

    function renderColorGuessingGame() {
      gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
      gameCtx.fillStyle = targetColor;
      gameCtx.fillRect(50, 50, 300, 100);
      for (let i = 0; i < 3; i++) {
        gameCtx.fillStyle = colorOptions[i];
        gameCtx.fillRect(50 + i * 100, 200, 80, 80);
      }
    }

    function handleColorGuess(e) {
      console.log("Color guess clicked");
      const rect = gameCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (y >= 200 && y <= 280) {
        const index = Math.floor((x - 50) / 100);
        if (index >= 0 && index < 3) {
          if (colorOptions[index] === targetColor) {
            gameScore += 5;
            showRewardAnimation();
            document.getElementById("gameScore").textContent = `Score: ${gameScore}`;
            generateColorRound();
          } else {
            gameScore = Math.max(0, gameScore - 2);
            document.getElementById("gameScore").textContent = `Score: ${gameScore}`;
          }
        }
      }
    }

    function startDrawingGame() {
      console.log("Starting Drawing Challenge");
      currentGame = "drawingChallenge";
      document.getElementById("gameContainer").style.display = "flex";
      document.getElementById("gameTitle").textContent = "Drawing Challenge";
      const words = ["cat", "flower", "house"];
      drawingChallengeWord = words[Math.floor(Math.random() * words.length)];
      document.getElementById("gameInstructions").textContent = `Draw a ${drawingChallengeWord} in 30 seconds!`;
      gameScore = 0;
      document.getElementById("gameScore").textContent = `Time Left: ${timeLeft}s`;
      gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
      timeLeft = 30;
      drawingChallengeTimer = setInterval(() => {
        timeLeft--;
        document.getElementById("gameScore").textContent = `Time Left: ${timeLeft}s`;
        if (timeLeft <= 0) {
          clearInterval(drawingChallengeTimer);
          alert("Time's up!");
          closeGame();
        }
      }, 1000);
      gameCanvas.onmousedown = startGameDrawing;
      gameCanvas.onmousemove = drawInGame;
      gameCanvas.onmouseup = stopGameDrawing;
    }

    let gameDrawing = false;
    let gameLastPoint = null;

    function startGameDrawing(e) {
      console.log("Starting game drawing");
      gameDrawing = true;
      drawInGame(e);
    }

    function stopGameDrawing() {
      console.log("Stopping game drawing");
      gameDrawing = false;
      gameCtx.beginPath();
      gameLastPoint = null;
    }

    function drawInGame(e) {
      if (!gameDrawing) return;
      const rect = gameCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      gameCtx.strokeStyle = brushColor;
      gameCtx.lineWidth = brushSize;
      gameCtx.lineJoin = "round";
      gameCtx.lineCap = "round";
      if (gameLastPoint) {
        gameCtx.beginPath();
        gameCtx.moveTo(gameLastPoint.x, gameLastPoint.y);
        gameCtx.lineTo(x, y);
        gameCtx.stroke();
      }
      gameLastPoint = { x, y };
    }

    // Science Quiz Game
    function startScienceQuiz() {
      console.log("Starting Science Quiz");
      currentGame = "scienceQuiz";
      document.getElementById("gameContainer").style.display = "flex";
      document.getElementById("gameTitle").textContent = "Science Quiz Game";
      document.getElementById("gameInstructions").textContent = "Click the correct answer to earn points!";
      gameScore = 0;
      currentQuestion = 0;
      document.getElementById("gameScore").textContent = `Score: ${gameScore}`;
      questions = [
        { question: "What planet is known as the Red Planet?", answers: ["Mars", "Venus", "Jupiter"], correct: 0 },
        { question: "What is the largest organ in the human body?", answers: ["Heart", "Skin", "Lung"], correct: 1 },
        { question: "What force pulls objects to the ground?", answers: ["Magnetism", "Gravity", "Electricity"], correct: 1 }
      ];
      renderScienceQuiz();
      gameCanvas.onclick = handleQuizAnswer;
    }

    function renderScienceQuiz() {
      gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
      if (currentQuestion >= questions.length) {
        gameCtx.font = "30px Comic Sans MS";
        gameCtx.fillStyle = "black";
        gameCtx.fillText(`Game Over! Score: ${gameScore}`, 50, 200);
        gameCanvas.onclick = null;
        return;
      }
      const q = questions[currentQuestion];
      gameCtx.font = "20px Comic Sans MS";
      gameCtx.fillStyle = "black";
      gameCtx.fillText(q.question, 50, 100);
      for (let i = 0; i < q.answers.length; i++) {
        gameCtx.fillStyle = "#ff66b2";
        gameCtx.fillRect(50, 150 + i * 60, 300, 50);
        gameCtx.fillStyle = "white";
        gameCtx.fillText(q.answers[i], 60, 180 + i * 60);
      }
    }

    function handleQuizAnswer(e) {
      console.log("Quiz answer clicked");
      const rect = gameCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const q = questions[currentQuestion];
      for (let i = 0; i < q.answers.length; i++) {
        if (x >= 50 && x <= 350 && y >= 150 + i * 60 && y <= 200 + i * 60) {
          if (i === q.correct) {
            gameScore += 10;
            showRewardAnimation();
            document.getElementById("gameScore").textContent = `Score: ${gameScore}`;
          } else {
            gameScore = Math.max(0, gameScore - 2);
            document.getElementById("gameScore").textContent = `Score: ${gameScore}`;
          }
          currentQuestion++;
          renderScienceQuiz();
          break;
        }
      }
    }

    // Barbie Dress-Up Game
    function startBarbieDressUp() {
      console.log("Starting Barbie Dress-Up");
      currentGame = "barbieDressUp";
      document.getElementById("gameContainer").style.display = "flex";
      document.getElementById("gameTitle").textContent = "Barbie Dress-Up Game";
      document.getElementById("gameInstructions").textContent = "Click to change dress color or pattern!";
      gameScore = 0;
      document.getElementById("gameScore").textContent = `Creations: ${gameScore}`;
      barbieOutfit = { dressColor: "#ff66b2", pattern: "none" };
      renderBarbieDressUp();
      gameCanvas.onclick = handleBarbieDressUp;
    }

    function renderBarbieDressUp() {
      gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
      // Draw Barbie (simplified as a dress shape)
      gameCtx.fillStyle = barbieOutfit.dressColor;
      gameCtx.beginPath();
      gameCtx.moveTo(200, 100);
      gameCtx.lineTo(150, 300);
      gameCtx.lineTo(250, 300);
      gameCtx.closePath();
      gameCtx.fill();
      if (barbieOutfit.pattern === "stars") {
        gameCtx.fillStyle = "white";
        for (let i = 0; i < 5; i++) {
          gameCtx.beginPath();
          gameCtx.arc(170 + i * 20, 150 + i * 30, 5, 0, Math.PI * 2);
          gameCtx.fill();
        }
      }
      // Color options
      const colors = ["#ff66b2", "#66b3ff", "#66ffb3"];
      for (let i = 0; i < colors.length; i++) {
        gameCtx.fillStyle = colors[i];
        gameCtx.fillRect(50 + i * 100, 320, 80, 40);
      }
      // Pattern options
      gameCtx.fillStyle = "#ff99cc";
      gameCtx.fillRect(50, 360, 80, 40);
      gameCtx.fillStyle = "white";
      gameCtx.fillText("None", 60, 385);
      gameCtx.fillStyle = "#ff99cc";
      gameCtx.fillRect(150, 360, 80, 40);
      gameCtx.fillStyle = "white";
      gameCtx.fillText("Stars", 160, 385);
    }

    function handleBarbieDressUp(e) {
      console.log("Barbie dress-up clicked");
      const rect = gameCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      // Color selection
      if (y >= 320 && y <= 360) {
        const index = Math.floor((x - 50) / 100);
        if (index >= 0 && index < 3) {
          barbieOutfit.dressColor = ["#ff66b2", "#66b3ff", "#66ffb3"][index];
          gameScore++;
          showRewardAnimation();
          document.getElementById("gameScore").textContent = `Creations: ${gameScore}`;
          renderBarbieDressUp();
        }
      }
      // Pattern selection
      if (y >= 360 && y <= 400) {
        if (x >= 50 && x <= 130) {
          barbieOutfit.pattern = "none";
          gameScore++;
          showRewardAnimation();
          document.getElementById("gameScore").textContent = `Creations: ${gameScore}`;
          renderBarbieDressUp();
        } else if (x >= 150 && x <= 230) {
          barbieOutfit.pattern = "stars";
          gameScore++;
          showRewardAnimation();
          document.getElementById("gameScore").textContent = `Creations: ${gameScore}`;
          renderBarbieDressUp();
        }
      }
    }

    // Science Experiment Game
    function startScienceExperiment() {
      console.log("Starting Science Experiment");
      currentGame = "scienceExperiment";
      document.getElementById("gameContainer").style.display = "flex";
      document.getElementById("gameTitle").textContent = "Science Experiment Game";
      document.getElementById("gameInstructions").textContent = "Click chemicals to mix them!";
      gameScore = 0;
      document.getElementById("gameScore").textContent = `Reactions: ${gameScore}`;
      experimentChemicals = [];
      renderScienceExperiment();
      gameCanvas.onclick = handleExperimentMix;
    }

    function renderScienceExperiment() {
      gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
      // Draw beaker
      gameCtx.strokeStyle = "black";
      gameCtx.lineWidth = 2;
      gameCtx.beginPath();
      gameCtx.moveTo(150, 100);
      gameCtx.lineTo(150, 300);
      gameCtx.lineTo(250, 300);
      gameCtx.lineTo(250, 100);
      gameCtx.stroke();
      // Draw mixed color
      if (experimentChemicals.length > 0) {
        const mixedColor = experimentChemicals.length === 2 ? mixColors(experimentChemicals[0], experimentChemicals[1]) : experimentChemicals[0];
        gameCtx.fillStyle = mixedColor;
        gameCtx.fillRect(150, 200, 100, 100);
      }
      // Chemical options
      const chemicals = ["#ff0000", "#00ff00", "#0000ff"];
      for (let i = 0; i < chemicals.length; i++) {
        gameCtx.fillStyle = chemicals[i];
        gameCtx.fillRect(50 + i * 100, 320, 80, 40);
      }
    }

    function mixColors(c1, c2) {
      if ((c1 === "#ff0000" && c2 === "#00ff00") || (c1 === "#00ff00" && c2 === "#ff0000")) return "#ffff00";
      if ((c1 === "#ff0000" && c2 === "#0000ff") || (c1 === "#0000ff" && c2 === "#ff0000")) return "#ff00ff";
      if ((c1 === "#00ff00" && c2 === "#0000ff") || (c1 === "#0000ff" && c2 === "#00ff00")) return "#00ffff";
      return c1;
    }

    function handleExperimentMix(e) {
      console.log("Experiment chemical clicked");
      const rect = gameCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (y >= 320 && y <= 360) {
        const index = Math.floor((x - 50) / 100);
        if (index >= 0 && index < 3) {
          experimentChemicals.push(["#ff0000", "#00ff00", "#0000ff"][index]);
          if (experimentChemicals.length > 2) experimentChemicals.shift();
          gameScore++;
          showRewardAnimation();
          document.getElementById("gameScore").textContent = `Reactions: ${gameScore}`;
          renderScienceExperiment();
        }
      }
    }

    // Tutorial functions
    function showStepByStep(type) {
      console.log(`Starting tutorial: ${type}`);
      document.getElementById("gameContainer").style.display = "flex";
      document.getElementById("gameTitle").textContent = `Learn to Draw a ${type.charAt(0).toUpperCase() + type.slice(1)}`;
      document.getElementById("gameInstructions").textContent = "Click to see the next step!";
      document.getElementById("gameScore").textContent = "";
      const steps = {
        cat: [
          () => {
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            gameCtx.beginPath();
            gameCtx.arc(200, 200, 80, 0, Math.PI * 2);
            gameCtx.stroke();
            gameCtx.fillText("Step 1: Draw a circle", 50, 350);
          },
          () => {
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            gameCtx.beginPath();
            gameCtx.arc(200, 200, 80, 0, Math.PI * 2);
            gameCtx.stroke();
            gameCtx.beginPath();
            gameCtx.moveTo(160, 120);
            gameCtx.lineTo(140, 80);
            gameCtx.lineTo(180, 100);
            gameCtx.closePath();
            gameCtx.stroke();
            gameCtx.beginPath();
            gameCtx.moveTo(240, 120);
            gameCtx.lineTo(260, 80);
            gameCtx.lineTo(220, 100);
            gameCtx.closePath();
            gameCtx.stroke();
            gameCtx.fillText("Step 2: Add ears", 50, 350);
          },
          () => {
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            gameCtx.beginPath();
            gameCtx.arc(200, 200, 80, 0, Math.PI * 2);
            gameCtx.stroke();
            gameCtx.beginPath();
            gameCtx.moveTo(160, 120);
            gameCtx.lineTo(140, 80);
            gameCtx.lineTo(180, 100);
            gameCtx.closePath();
            gameCtx.stroke();
            gameCtx.beginPath();
            gameCtx.moveTo(240, 120);
            gameCtx.lineTo(260, 80);
            gameCtx.lineTo(220, 100);
            gameCtx.closePath();
            gameCtx.stroke();
            gameCtx.beginPath();
            gameCtx.arc(180, 180, 5, 0, Math.PI * 2);
            gameCtx.fill();
            gameCtx.beginPath();
            gameCtx.arc(220, 180, 5, 0, Math.PI * 2);
            gameCtx.fill();
            gameCtx.fillText("Step 3: Add eyes", 50, 350);
          }
        ],
        flower: [
          () => {
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            gameCtx.beginPath();
            gameCtx.arc(200, 200, 20, 0, Math.PI * 2);
            gameCtx.stroke();
            gameCtx.fillText("Step 1: Draw a circle", 50, 350);
          },
          () => {
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            gameCtx.beginPath();
            gameCtx.arc(200, 200, 20, 0, Math.PI * 2);
            gameCtx.stroke();
            for (let i = 0; i < 4; i++) {
              const angle = (i / 4) * Math.PI * 2;
              gameCtx.beginPath();
              gameCtx.ellipse(200 + Math.cos(angle) * 40, 200 + Math.sin(angle) * 40, 10, 20, angle, 0, Math.PI * 2);
              gameCtx.stroke();
            }
            gameCtx.fillText("Step 2: Add petals", 50, 350);
          },
          () => {
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            gameCtx.beginPath();
            gameCtx.arc(200, 200, 20, 0, Math.PI * 2);
            gameCtx.stroke();
            for (let i = 0; i < 4; i++) {
              const angle = (i / 4) * Math.PI * 2;
              gameCtx.beginPath();
              gameCtx.ellipse(200 + Math.cos(angle) * 40, 200 + Math.sin(angle) * 40, 10, 20, angle, 0, Math.PI * 2);
              gameCtx.stroke();
            }
            gameCtx.beginPath();
            gameCtx.moveTo(200, 220);
            gameCtx.lineTo(200, 300);
            gameCtx.stroke();
            gameCtx.fillText("Step 3: Add stem", 50, 350);
          }
        ]
      };
      let currentStep = 0;
      steps[type][currentStep]();
      gameCanvas.onclick = () => {
        console.log(`Advancing to step ${currentStep + 1}`);
        currentStep = (currentStep + 1) % steps[type].length;
        steps[type][currentStep]();
      };
    }
  </script>
</body>
</html>
